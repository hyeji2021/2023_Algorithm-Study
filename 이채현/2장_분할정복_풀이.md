# 2.1절 2번 문제
Q. 좀 비현실적이기는 하지만 이분검색（알고리즘 2.1） 알고리즘을 사용하여 원소가 7억 개인 배열을 검색한다고 가정해보자. 
    특정 원소를 찾기 위해서 비교를 최대로 몇 번해야 할까? 특정 원소가 배열에 있을 수도 있고 없을 수도 있다


```C++
//알고리즘2.1
index location (index low, index high) {
	index mid;
	if(low > high)
		return 0;
	else{
		mid =  \_{Iow 十 high)/2 J ;
	  if (x == S[mid]
	  	return mid;
	  else if (x < S[mid])
		  return location(low, mid-1);
	  else
		  return location(mid+1, high);
	}
}
```

교재 알고리즘 2.1 분석에 따르면 배열 원소의 개수가 n일 때, 재현식은 W(n) = W(n/2) + 1 이다.

W(700,000,000) = W(350,000,000) + 1
               = W(175,000,000) + 2
               = W(87,500,000) + 3
               = W(43,750,000) + 4
               = ... 
               = W(1.303) + 29
	       = W(0.652) + 30
	       ≒ 31
	      
위의 식에 따라 약 31번 비교해야 함을 알 수 있다. 


# 2.3절 16번 문제
Q. 분할정복 알고리즘에서 크기가 n인 문제의 입력사례를 n/3 크기의 10개의 입력사례로 항상 분할하고, 분할하고 합병하는 과정은 θ(n^2)의 시간이 걸린다고 가정하자. 실행시간 T(n)을 나타내는 재현식을 작성하고, 그 식의 해를 구하시오.

입력사례를 n/2로 분할하는 기존식

W(n) = W(h) + W(m) + h + m - 1 = (U를 정렬하는데 걸리는 시간) + (V를 정렬하는데 걸리는 시간) + 합병하는데 걸리는 시간

	T(n) = T(n/3) + T(n/3) + T(n/3) + n/3 + 2/3*n - 1
	     = 3T(n/3) + n - 1
